# -*- coding: utf-8 -*-
"""Camera Calibration-ADRG.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1madncdBo56DICzi3quUancVjfS1E2TJB
"""

import cv2
from cv2 import aruco
import numpy as np    #importing all libraries
import math
from google.colab.patches import cv2_imshow

class aruco1:

  def __init__(self):
    self.objp=[]
    self.obj=[]
    self.imgp=[]

    
    self.im1=cv2.imread("pic5.jpg")
    self.im1=cv2.resize(self.im1,(280,280))                                             #reading the picture
    self.img1=cv2.cvtColor(self.im1,cv2.COLOR_BGR2GRAY)                         #converting the picture to grayscale
    print(self.im1.shape)
    
    self.arucoDict=cv2.aruco.Dictionary_get(cv2.aruco.DICT_6X6_1000)            #initialising the aruco dictionary for 6x6 markers
    self.arucoParam=cv2.aruco.DetectorParameters_create()                       #creating the parameters

    self.corners,self.ids,self.rej=cv2.aruco.detectMarkers(self.img1,self.arucoDict,parameters=self.arucoParam) #Detecting the four image corners of the aruco marker and the id
    print(self.ids)
    self.imgp.append(self.corners)                                              #Storing the corners in imgp which will later be converted into a numpy array


    self.objp = np.zeros((4,3), np.float32)                                     #Initialising objp to store the 3D coordinates of the 4 corners

    self.imgp=np.array([corner for [corner] in self.imgp])                      #converting imgp into a numpy array and reshaping it

    self.imgp.astype('float32')
    self.objp=np.array([self.objp])
    self.objp.astype('float32')
    self.objp[0][0][0]=0
    self.objp[0][0][1]=0
    self.objp[0][1][0]=472
    self.objp[0][1][1]=0                                                        #Hardcoding the 3D coordinates of the corners whcih I obtained from another picture taken with no rotation of the 3D coordinate system 
    self.objp[0][2][0]=472
    self.objp[0][2][1]=473
    self.objp[0][3][0]=0
    self.objp[0][3][1]=473
    self.obj.append(self.objp)

    self.obj=np.array([corner for [corner] in self.obj])
  
  def calibrate(self):

    self.ret,self.mat,self.dist,self.rvec,self.tvec=cv2.calibrateCamera(self.obj,self.imgp,self.img1.shape[::-1],None,None)
    
    print("Distance of camera from aruco marker = ")
    print(math.sqrt(self.tvec[0][0][0]*self.tvec[0][0][0]+self.tvec[0][1][0]*self.tvec[0][1][0]+self.tvec[0][2][0]*self.tvec[0][2][0]))                                                             
    print("Roll=")
    print(self.rvec[0][0][0])
    print("Pitch=")
    print(self.rvec[0][1][0])
    print("Yaw=")
    print(self.rvec[0][2][0])    

                                                   

  def form_matrices(self):

    self.a=np.float32([[math.cos(self.rvec[0][0][0]),-1*math.sin(self.rvec[0][0][0]),0],[math.sin(self.rvec[0][0][0]),math.cos(self.rvec[0][0][0]),0],[0,0,1]])
    self.b=np.float32([[1,0,0],[0,math.cos(self.rvec[0][1][0]),-1*math.sin(self.rvec[0][1][0])],[0,math.sin(self.rvec[0][1][0]),math.cos(self.rvec[0][1][0])]])
    self.c=np.float32([[math.cos(self.rvec[0][2][0]),0,-1*math.sin(self.rvec[0][2][0])],[0,1,0],[math.sin(self.rvec[0][2][0]),0,math.cos(self.rvec[0][2][0])]])
    self.k=np.dot(self.a,self.b)
    self.k=np.dot(self.k,self.c)                                                #Forming and storing the rotation matrix
    
    at=self.a.transpose()
    bt=self.b.transpose()
    ct=self.c.transpose()
    k1=np.dot(ct,bt)
    k1=np.dot(k1,at)

    self.matrix=np.zeros((4,4),np.float32)
    for i in (0,1,2):
      for j in (0,1,2):
        self.matrix[i][j]=self.k[i][j]
    self.matrix[0][3]=self.tvec[0][0][0]
    self.matrix[1][3]=self.tvec[0][1][0]
    self.matrix[2][3]=self.tvec[0][2][0]
   
    self.matrix[3][0]=0
    self.matrix[3][1]=0
    self.matrix[3][2]=0                                                         #Adding the translation component and making it 4x4
    self.matrix[3][3]=1

    self.matrix1=np.zeros((4,4),np.float32)
    for i in (0,1,2):
      for j in (0,1,2):
        self.matrix1[i][j]=k1[i][j]
    self.matrix1[0][3]=0
    self.matrix1[1][3]=0
    self.matrix1[2][3]=4000
   
    self.matrix1[3][0]=0
    self.matrix1[3][1]=0
    self.matrix1[3][2]=0                                                         #Adding the translation component and making it 4x4
    self.matrix1[3][3]=1
    
    mat1=np.zeros((3,4),np.float32)
    for i in (0,1,2):
      for j in (0,1,2):                                                         #Forming the 3x4 calibration matrix
        mat1[i][j]=self.mat[i][j]
    
    i=float(123)
    mat4=np.float32([[1,0,0,i],[0,1,0,i],[0,0,1,4000],[0,0,0,1]])
  
    mat3=np.dot(mat1,mat4)
   
   
    mat1=np.dot(mat1,self.matrix)
    mat2=mat1.transpose()                                                       #Forming the homography for top view perspective transform
    mat2=np.dot(mat1,mat2)
    mat2=np.linalg.inv(mat2)
    mat2=np.dot(mat1.transpose(),mat2)
    
    mat3=np.dot(mat3,mat2)
    pts2=np.float32([[0,0],[280,0],[280,280],[0,280]])
    h=cv2.getPerspectiveTransform(self.imgp[0][0],pts2)
    
    
   
    o=cv2.warpPerspective(self.im1,h,(280,280))
   
    cv2_imshow(self.im1)
    cv2_imshow(o)
    cv2.waitKey(0)


c=aruco1()                                                                      #Initialising the class variables and functions
c.calibrate()
c.form_matrices()                                                               #Calling the functions